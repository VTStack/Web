"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const from_1 = require("rxjs/internal/observable/from");
const switchMap_1 = require("rxjs/internal/operators/switchMap");
const environment_1 = require("./utilities/environment");
const axios_1 = require("./utilities/axios");
const cloud_enabled_runner_1 = require("./core/runners/cloud-enabled/cloud-enabled.runner");
const { tasksRunnerV2, output } = require('./utilities/nx-imports');
const nxCloudTasksRunner = (tasks, options, context) => {
    if (!environment_1.ACCESS_TOKEN && !options.accessToken) {
        return tasksRunnerV2(tasks, options, context);
    }
    if (environment_1.NX_NO_CLOUD) {
        return tasksRunnerV2(tasks, options, context);
    }
    if (environment_1.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION) {
        verifyAllOperationsAreCacheableOnAgent(tasks, options);
    }
    // distributed execution main job
    if (process.env.NX_CLOUD_DISTRIBUTED_EXECUTION === 'true' &&
        !environment_1.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION) {
        verifyAllOperationsAreCacheableOnMainJob(tasks, options);
        return (0, from_1.from)(verifyNxCloudWorkspaceEnabled(options)).pipe((0, switchMap_1.switchMap)((res) => {
            if (res.data.enabled) {
                return require('./core/runners/distributed-execution/distributed-execution.runner').nxCloudDistributedTasksRunner(tasks, options, context);
            }
            output.warn({
                title: 'Nx Cloud: Workspace Disabled',
                bodyLines: [
                    'This run and following runs will not use distributed task execution until',
                    'the outstanding balance is paid or additional coupons are added for this',
                    'workspace. If you believe you are receiving this message in error, please',
                    'contact support at cloud-support@nrwl.io.',
                    '',
                    'Execution will now continue using this machine only.',
                ],
            });
            // This disables using Cloud for all inner nx invocations, so it won't create an extra run.
            process.env.NX_CLOUD = 'false';
            return (0, cloud_enabled_runner_1.cloudEnabledTasksRunner)(tasks, options, context);
        }));
    }
    // This disables using Cloud for all inner nx invocations, so it won't create an extra run.
    process.env.NX_CLOUD = 'false';
    return (0, cloud_enabled_runner_1.cloudEnabledTasksRunner)(tasks, options, context);
};
function verifyNxCloudWorkspaceEnabled(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const axiosInstance = (0, axios_1.createApiAxiosInstance)(options);
        return yield (0, axios_1.axiosMultipleTries)(() => axiosInstance.get('/nx-cloud/executions/workspace-status'));
    });
}
function verifyAllOperationsAreCacheableOnMainJob(tasks, options) {
    const cacheableTargets = options.cacheableOperations || [];
    tasks.forEach((task) => {
        if (cacheableTargets.indexOf(task.target.target) === -1) {
            output.error({
                title: `Distributed task execution only works for cacheable targets`,
                bodyLines: [
                    `Target '${task.target.project}:${task.target.target}' cannot be executed.`,
                    `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
                    `You can verify that '${task.target.target}' is part of the list of cacheable targets in the 'nx.json' file.`,
                    `You can invoke this command without distribution by doing "NX_CLOUD_DISTRIBUTED_EXECUTION=false nx ...".`,
                ],
            });
            process.exit(1);
        }
    });
}
function verifyAllOperationsAreCacheableOnAgent(tasks, options) {
    const cacheableTargets = options.cacheableOperations || [];
    tasks.forEach((task) => {
        if (cacheableTargets.indexOf(task.target.target) === -1) {
            output.error({
                title: `Distributed task execution only works for cacheable targets`,
                bodyLines: [
                    `Target ${task.target.project}:${task.target.target} cannot be executed.`,
                    `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
                    `You can still invoke "nx ${task.target.target} ${task.target.project}" from within a cacheable target when using "@nrwl/workspace:run-commands".`,
                ],
            });
            process.exit(environment_1.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
        }
    });
}
exports.default = nxCloudTasksRunner;
//# sourceMappingURL=nx-cloud-tasks-runner.js.map